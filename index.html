from fastapi import FastAPI, HTTPException, UploadFile, File, Path
from pydantic import BaseModel
import subprocess
import requests
from datetime import datetime
import os
import shutil
import logging
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse

# Инициализация FastAPI
app = FastAPI()

# Настройка CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Разрешить все домены
    allow_credentials=True,
    allow_methods=["*"],  # Разрешить все методы (GET, POST, OPTIONS и т.д.)
    allow_headers=["*"],  # Разрешить все заголовки
)

# Логирование
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Настройки
MAC_ADDRESS = "74:56:3c:96:53:39"
OWM_API_KEY = "3d79aa1b71dbdda6d891f3f04245840d"  # Ваш API-ключ
CITY = "Balashikha"  # Город Балашиха
STORAGE_PATH = "/home/tema/Files"  # Укажите путь к папке хранилища

# Модели запросов
class WakeOnLANRequest(BaseModel):
    mac_address: str = MAC_ADDRESS

class FileRequest(BaseModel):
    file_name: str
    action: str  # delete, download

class CreateFolderRequest(BaseModel):
    folder_name: str

# Команда Wake-on-LAN
@app.post("/wol")
async def wake_on_lan(request: WakeOnLANRequest):
    try:
        # Проверяем, установлена ли команда wakeonlan
        if not shutil.which("wakeonlan"):
            raise HTTPException(status_code=500, detail="Команда wakeonlan не установлена.")

        subprocess.run(['wakeonlan', request.mac_address], check=True)
        return {"status": "success", "message": "Magic Packet отправлен."}
    except subprocess.CalledProcessError as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при отправке Magic Packet: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка: {e}")

# Получение погоды
@app.get("/weather")
async def get_weather(city: str = CITY):
    try:
        url = f"http://api.openweathermap.org/data/2.5/forecast?q={city}&appid={OWM_API_KEY}&units=metric&lang=ru"
        response = requests.get(url)
        data = response.json()

        if response.status_code == 200:
            weather_data = data['list']
            today = datetime.now().strftime("%Y-%m-%d")
            today_weather = [w for w in weather_data if w['dt_txt'].startswith(today)]

            if today_weather:
                formatted_weather = []
                for entry in today_weather:
                    formatted_weather.append({
                        "time": entry['dt_txt'][11:16],
                        "temp": int(entry['main']['temp']),
                        "description": entry['weather'][0]['description'],
                        "humidity": entry['main']['humidity'],
                        "wind_speed": int(entry['wind']['speed']),
                        "icon": entry['weather'][0]['icon']
                    })
                return {"status": "success", "data": formatted_weather}
            else:
                return {"status": "error", "message": "Данные о погоде на сегодня отсутствуют."}
        else:
            return {"status": "error", "message": f"Ошибка при получении данных: {data['message']}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при получении погоды: {e}")

# Получение курсов криптовалют
@app.get("/crypto")
async def get_crypto(coins: str = "bitcoin,ethereum,solana"):
    try:
        url = "https://api.coingecko.com/api/v3/simple/price"
        params = {
            'ids': coins,
            'vs_currencies': 'usd,rub',
            'include_market_cap': 'true',
            'include_24hr_vol': 'true',
            'include_24hr_change': 'true'
        }
        response = requests.get(url, params=params)
        data = response.json()

        if response.status_code == 200:
            crypto_data = []
            for crypto, info in data.items():
                crypto_data.append({
                    "name": crypto.capitalize(),
                    "price_usd": info['usd'],
                    "price_rub": info['rub'],
                    "change": info['usd_24h_change'],
                    "market_cap": info['usd_market_cap'],
                    "volume": info['usd_24h_vol']
                })
            return {"status": "success", "data": crypto_data}
        else:
            return {"status": "error", "message": f"Ошибка при получении данных: {response.status_code}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при получении курсов криптовалют: {e}")

# Получение списка файлов и папок
@app.get("/list-files")
async def list_files(path: str = STORAGE_PATH):
    try:
        # Проверка безопасности: предотвращаем выход за пределы корневой директории
        if not os.path.abspath(path).startswith(os.path.abspath(STORAGE_PATH)):
            raise HTTPException(status_code=403, detail="Доступ запрещен.")

        items = os.listdir(path)
        files = [item for item in items if os.path.isfile(os.path.join(path, item))]
        folders = [item for item in items if os.path.isdir(os.path.join(path, item))]

        return {
            "status": "success",
            "files": files,
            "folders": folders,
            "current_directory": path
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при получении списка файлов: {e}")

# Удаление файла или папки
@app.post("/delete-file")
async def delete_file(request: FileRequest):
    try:
        item_path = os.path.join(STORAGE_PATH, request.file_name)

        if not os.path.exists(item_path):
            return {"status": "error", "message": f"Файл или папка {request.file_name} не найдена."}

        if os.path.isfile(item_path):
            os.remove(item_path)
            return {"status": "success", "message": f"Файл {request.file_name} успешно удален."}
        else:
            shutil.rmtree(item_path)
            return {"status": "success", "message": f"Папка {request.file_name} успешно удалена."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при удалении: {e}")

# Создание папки
@app.post("/create-folder")
async def create_folder(request: CreateFolderRequest):
    try:
        folder_path = os.path.join(STORAGE_PATH, request.folder_name)

        if os.path.exists(folder_path):
            return {"status": "error", "message": f"Папка {request.folder_name} уже существует."}

        os.makedirs(folder_path)
        return {"status": "success", "message": f"Папка {request.folder_name} успешно создана."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при создании папки: {e}")

# Загрузка файла
@app.post("/upload-file")
async def upload_file(file: UploadFile = File(...)):
    try:
        file_path = os.path.join(STORAGE_PATH, file.filename)

        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        return {"status": "success", "message": f"Файл {file.filename} успешно загружен."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при загрузке файла: {e}")

# Скачивание файла
@app.get("/download-file/{file_name}")
async def download_file(file_name: str):
    try:
        file_path = os.path.join(STORAGE_PATH, file_name)

        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail="Файл не найден.")

        return FileResponse(file_path, filename=file_name)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка при скачивании файла: {e}")

# Запуск сервера
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        ssl_keyfile="/etc/letsencrypt/live/aaero.ddns.net/privkey.pem",  # Приватный ключ
        ssl_certfile="/etc/letsencrypt/live/aaero.ddns.net/fullchain.pem"  # Сертификат
    )





































<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Управление ПК и файлами</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 20px;
        padding: 0;
        background-color: #f9f9f9;
    }
    h1 {
        color: #333;
        text-align: center;
    }
    button {
        padding: 10px 20px;
        margin: 5px;
        font-size: 16px;
        cursor: pointer;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        transition: background-color 0.3s ease;
    }
    button:hover {
        background-color: #0056b3;
    }
    .data-list {
        margin-top: 20px;
    }
    .data-item {
        display: flex;
        align-items: center;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .data-item i {
        font-size: 24px;
        margin-right: 10px;
        color: #007bff;
    }
    .data-item .content {
        flex-grow: 1;
    }
    .data-item .content p {
        margin: 5px 0;
        font-size: 14px;
        color: #555;
    }
    .weather-container {
        display: flex;
        gap: 20px;
        margin-top: 20px;
    }
    .current-weather {
        flex: 1;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .forecast {
        flex: 1;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .forecast h3 {
        margin-top: 0;
        color: #007bff;
    }
    .forecast-item {
        display: flex;
        justify-content: space-between;
        padding: 10px 0;
        border-bottom: 1px solid #eee;
    }
    .forecast-item:last-child {
        border-bottom: none;
    }
    .card {
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .card h3 {
        margin-top: 0;
        color: #007bff;
    }
    .card p {
        margin: 5px 0;
        font-size: 14px;
        color: #555;
    }
    .crypto-container {
        display: flex;
        gap: 20px;
        margin-top: 20px;
    }
    .crypto-info {
        flex: 1;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .crypto-details {
        flex: 1;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .crypto-details h3 {
        margin-top: 0;
        color: #007bff;
    }
    .crypto-details p {
        margin: 5px 0;
        font-size: 14px;
        color: #555;
    }
    .file-list {
        margin-top: 20px;
    }
    .file-list ul {
        list-style-type: none;
        padding: 0;
    }
    .file-list li {
        margin: 5px 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 5px;
    }
    .file-list button {
        margin-left: 10px;
        background-color: #dc3545;
        color: white;
        border: none;
        border-radius: 5px;
        padding: 5px 10px;
        cursor: pointer;
    }
    .file-list button:hover {
        background-color: #c82333;
    }
    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    /* Адаптация для мобильных устройств */
    @media (max-width: 600px) {
        h1 {
            font-size: 24px;
        }
        button {
            width: 100%;
            margin: 5px 0;
        }
        .weather-container, .crypto-container {
            flex-direction: column;
        }
        .card, .current-weather, .forecast, .crypto-info, .crypto-details {
            padding: 15px;
        }
    }
</style>
</head>
<body>
    <div class="container">
        <h1>Управление ПК и файлами</h1>

        <button onclick="wakeOnLAN()">🖥 Включить ПК</button>
        <button onclick="getWeather()">🌤 Получить погоду</button>
        <button onclick="getCrypto()">📈 Курсы криптовалют</button>
        <button onclick="listFiles()">📁 Список файлов</button>
        <button onclick="uploadFile()">📤 Загрузить файл</button>
        <button onclick="createFolder()">📂 Создать папку</button>

        <h2>Результат:</h2>
        <div id="output"></div>

        <div class="file-list">
            <h2>Файлы и папки:</h2>
            <ul id="file-list"></ul>
        </div>
    </div>

    <script>
        // Вставьте сюда обновленный JavaScript-код
        const backendUrl = "https://aaero.ddns.net:8000";  // Замените на ваш URL
        const tg = window.Telegram.WebApp;  // Инициализация Telegram WebApp API
        let currentPath = "/home/tema/Files";  // Текущий путь
        let pathHistory = [];  // История путей для кнопки "Назад"

        // Функция для отправки запросов на backend
        async function sendRequest(endpoint, method = "GET", data = {}) {
            try {
                const response = await fetch(`${backendUrl}/${endpoint}`, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: method !== "GET" ? JSON.stringify(data) : null
                });

                if (!response.ok) {
                    throw new Error(`Ошибка: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.error("Ошибка при отправке запроса:", error);
                return { status: "error", message: error.message };
            }
        }

        // Включение ПК (Wake-on-LAN)
        async function wakeOnLAN() {
            const result = await sendRequest('wol', 'POST', { mac_address: '74:56:3c:96:53:39' });
            const output = document.getElementById('output');
            output.innerHTML = "";  // Очищаем предыдущий вывод

            if (result.status === "success") {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <h3>🖥 Wake-on-LAN</h3>
                    <p>✅ Magic Packet отправлен на MAC: ${result.mac_address}</p>
                `;
                output.appendChild(card);
            } else {
                output.innerText = result.message;
            }
        }

        // Получение погоды
        async function getWeather() {
            const result = await sendRequest('weather', 'GET');
            const output = document.getElementById('output');
            output.innerHTML = "";  // Очищаем предыдущий вывод

            if (result.status === "success") {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <h3>🌤 Текущая погода</h3>
                    <p>🌡 Температура: ${result.data[0].temp}°C</p>
                    <p>🌤 Погода: ${result.data[0].description}</p>
                    <p>💧 Влажность: ${result.data[0].humidity}%</p>
                    <p>🌬 Ветер: ${result.data[0].wind_speed} м/с</p>
                `;
                output.appendChild(card);
            } else {
                output.innerText = result.message;
            }
        }

        // Получение курсов криптовалют
        async function getCrypto() {
            const result = await sendRequest('crypto', 'GET');
            const output = document.getElementById('output');
            output.innerHTML = "";  // Очищаем предыдущий вывод

            if (result.status === "success") {
                result.data.forEach(crypto => {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.innerHTML = `
                        <h3>💰 ${crypto.name}</h3>
                        <p>💰 USD: $${crypto.price_usd.toFixed(2)}</p>
                        <p>₽ RUB: ₽${crypto.price_rub.toFixed(2)}</p>
                        <p>📈 Изменение: ${crypto.change.toFixed(2)}%</p>
                        <p>💼 Капитал: $${(crypto.market_cap / 1e9).toFixed(2)}B</p>
                        <p>📊 Объем: $${(crypto.volume / 1e9).toFixed(2)}B</p>
                    `;
                    output.appendChild(card);
                });
            } else {
                output.innerText = result.message;
            }
        }

        // Получение списка файлов
        async function listFiles(path = currentPath) {
            const result = await sendRequest('list-files', 'GET', { path });
            const fileList = document.getElementById('file-list');
            output.innerHTML = "";  // Очищаем предыдущий вывод
            fileList.innerHTML = "";

            if (result.status === "success") {
                currentPath = result.current_directory;
                pathHistory.push(currentPath);  // Добавляем текущий путь в историю

                // Добавляем кнопку "Назад", если это не корневой каталог
                if (pathHistory.length > 1) {
                    const backButton = document.createElement('button');
                    backButton.innerText = "⬅️ Назад";
                    backButton.onclick = () => {
                        pathHistory.pop();  // Удаляем текущий путь из истории
                        const previousPath = pathHistory[pathHistory.length - 1];
                        listFiles(previousPath);
                    };
                    fileList.appendChild(backButton);
                }

                result.files.forEach(file => {
                    const li = document.createElement('li');
                    li.innerText = `📄 ${file}`;

                    const deleteButton = document.createElement('button');
                    deleteButton.innerText = "🗑 Удалить";
                    deleteButton.onclick = () => deleteFileOrFolder(file, 'file');

                    li.appendChild(deleteButton);
                    fileList.appendChild(li);
                });

                result.folders.forEach(folder => {
                    const li = document.createElement('li');
                    li.innerText = `📁 ${folder}`;

                    const openButton = document.createElement('button');
                    openButton.innerText = "📂 Открыть";
                    openButton.onclick = () => listFiles(`${currentPath}/${folder}`);

                    const deleteButton = document.createElement('button');
                    deleteButton.innerText = "🗑 Удалить";
                    deleteButton.onclick = () => deleteFileOrFolder(folder, 'folder');

                    li.appendChild(openButton);
                    li.appendChild(deleteButton);
                    fileList.appendChild(li);
                });
            } else {
                document.getElementById('output').innerText = JSON.stringify(result, null, 2);
            }
        }

        // Удаление файла или папки
        async function deleteFileOrFolder(name, type) {
            const confirmDelete = confirm(`Вы уверены, что хотите удалить ${type === 'file' ? 'файл' : 'папку'} "${name}"?`);
            if (confirmDelete) {
                const result = await sendRequest('delete-file', 'POST', { file_name: name, action: 'delete' });
                const output = document.getElementById('output');
                output.innerHTML = "";  // Очищаем предыдущий вывод

                if (result.status === "success") {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.innerHTML = `
                        <h3>${type === 'file' ? '🗑 Удаление файла' : '🗑 Удаление папки'}</h3>
                        <p>✅ ${type === 'file' ? 'Файл' : 'Папка'} "${name}" успешно удален(а).</p>
                    `;
                    output.appendChild(card);
                } else {
                    output.innerText = result.message;
                }
                listFiles();  // Обновляем список файлов
            } else {
                document.getElementById('output').innerText = "Удаление отменено.";
            }
        }

        // Создание папки
        async function createFolder() {
            const folderName = prompt("Введите имя новой папки:");
            if (folderName) {
                const result = await sendRequest('create-folder', 'POST', { folder_name: folderName });
                const output = document.getElementById('output');
                output.innerHTML = "";  // Очищаем предыдущий вывод

                if (result.status === "success") {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.innerHTML = `
                        <h3>📂 Создание папки</h3>
                        <p>✅ Папка "${folderName}" успешно создана.</p>
                    `;
                    output.appendChild(card);
                } else {
                    output.innerText = result.message;
                }
                listFiles();  // Обновляем список файлов
            }
        }

        // Загрузка файла
        async function uploadFile() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                const formData = new FormData();
                formData.append('file', file);

                try {
                    const response = await fetch(`${backendUrl}/upload-file`, {
                        method: 'POST',
                        body: formData
                    });
                    const result = await response.json();
                    document.getElementById('output').innerText = JSON.stringify(result, null, 2);
                    listFiles();  // Обновляем список файлов
                } catch (error) {
                    console.error("Ошибка при загрузке файла:", error);
                    document.getElementById('output').innerText = "Ошибка при загрузке файла.";
                }
            };
            fileInput.click();
        }

        // Инициализация Mini App Telegram
        tg.ready();  // Уведомляем Telegram, что приложение готово
    </script>
</body>
</html>
